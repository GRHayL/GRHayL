#include "Neutrinos.h"

/*
 * (c) Leo Werneck
 * Compute GRMHD source terms following Ruffert et al. (1996)
 * https://adsabs.harvard.edu/pdf/1996A%26A...311..532R
 */
void NRPyLeakage_compute_neutrino_opacities(
      const eos_parameters *restrict eos,
      const double rho,
      const double Y_e,
      const double T,
      const neutrino_optical_depths *restrict tau,
      neutrino_opacities *restrict kappa) {

  // Step 1: Get chemical potentials and mass
  //         fractions using the EOS
  double muhat, mu_e, mu_p, mu_n, X_n, X_p;
  eos->tabulated_compute_muhat_mue_mup_mun_Xn_Xp_from_T(eos, rho, Y_e, T, &muhat, &mu_e, &mu_p, &mu_n, &X_n, &X_p);

  // Step 2: Compute rho in cgs units
  const double rho_cgs = rho * NRPyLeakage_units_geom_to_cgs_D;

  // Step 3: Compute Y_{pn} and Y_{np}
  const double Y_p = Y_e;
  const double Y_n = 1-Y_e;
  const double exp_metahat = exp(-muhat/T);
  // Step 3.a: Compute Y_{np}
  double Y_np = (Y_e < 0.5) ? (2.0*Y_e-1.0)/(exp_metahat-1.0) : Y_n;

  // Step 3.b: Compute Y_{pn}
  double Y_pn = (Y_e > 0.5) ? exp_metahat*(2.0*Y_e-1.0)/(exp_metahat-1.0) : Y_p;

  // Step 3.c: Make sure both Y_np and Y_pn are non-negative
  if( Y_np < 0.0 ) Y_np = Y_n;
  if( Y_pn < 0.0 ) Y_pn = Y_p;

  // Leo says: this is the way ZelmaniLeak computes Y_pn and Y_np
  // Step 3: Compute Y_{pn} and Y_{np}
  // Step 3.a: Compute Y_{pn} (See discussion below Eq. A8 in https://arxiv.org/pdf/1306.4953.pdf)
  // double Y_pn;
  // if( rho_cgs > 2e12 ) {
  //   // Step 3.a.i: Use Eqs. (A13) and (A14) in https://adsabs.harvard.edu/pdf/1996A%26A...311..532R
  //   Y_pn = (2*Y_e - 1)/(1-exp(muhat/T));
  // }
  // else {
  //   Y_pn = 1-Y_e;
  // }
  // // Step 3.a.ii: Make sure Y_{pn} is nonzero
  // Y_pn = MAX(Y_pn,0.0);

  // // Step 3.b: Compute Y_{np} (Eq. A13 in https://adsabs.harvard.edu/pdf/1996A%26A...311..532R)
  // const double Y_np = exp(muhat/T) * Y_pn;

  // Step 4: Compute the source terms
  //         Note: The code below is generated by NRPy+
  const double tmp_0 = (1.0/(T));
  const double tmp_1 = mu_e*tmp_0;
  const double tmp_3 = -muhat*tmp_0 + tmp_1;
  const double tmp_4 = NRPyLeakage_Fermi_Dirac_integrals(4, tmp_3);
  const double tmp_5 = NRPyLeakage_N_A*NRPyLeakage_sigma_0*((T)*(T))*rho_cgs/((NRPyLeakage_m_e_c2)*(NRPyLeakage_m_e_c2));
  const double tmp_6 = tmp_4*tmp_5/NRPyLeakage_Fermi_Dirac_integrals(2, tmp_3);
  const double tmp_8 = (5.0/24.0)*((NRPyLeakage_alpha)*(NRPyLeakage_alpha));
  const double tmp_9 = (1 - Y_e)*(tmp_8 + 1.0/24.0)/((2.0/3.0)*MAX(mu_n*tmp_0, 0) + 1);
  const double tmp_10 = Y_e*(tmp_8 + (1.0/6.0)*((NRPyLeakage_C_V - 1)*(NRPyLeakage_C_V - 1)))/((2.0/3.0)*MAX(mu_p*tmp_0, 0) + 1);
  const double tmp_11 = NRPyLeakage_Fermi_Dirac_integrals(5, tmp_3);
  const double tmp_12 = (3.0/4.0)*((NRPyLeakage_alpha)*(NRPyLeakage_alpha)) + 1.0/4.0;
  const double tmp_13 = Y_np*tmp_12/(exp(tmp_1 - tmp_11/tmp_4) + 1);
  const double tmp_14 = tmp_11/NRPyLeakage_Fermi_Dirac_integrals(3, tmp_3);
  const double tmp_16 = tmp_10*tmp_5;
  const double tmp_18 = muhat*tmp_0 - tmp_1;
  const double tmp_19 = NRPyLeakage_Fermi_Dirac_integrals(4, tmp_18);
  const double tmp_20 = tmp_19/NRPyLeakage_Fermi_Dirac_integrals(2, tmp_18);
  const double tmp_22 = NRPyLeakage_Fermi_Dirac_integrals(5, tmp_18);
  const double tmp_23 = Y_pn*tmp_12/(exp(-tmp_1 - tmp_22/tmp_19) + 1);
  const double tmp_24 = tmp_22/NRPyLeakage_Fermi_Dirac_integrals(3, tmp_18);
  const double tmp_26 = NRPyLeakage_Fermi_Dirac_integrals(4, 0)/NRPyLeakage_Fermi_Dirac_integrals(2, 0);
  const double tmp_28 = NRPyLeakage_Fermi_Dirac_integrals(5, 0)/NRPyLeakage_Fermi_Dirac_integrals(3, 0);
  kappa->nue[0] = NRPyLeakage_units_geom_to_cgs_L*(tmp_10*tmp_6 + tmp_13*tmp_6 + tmp_6*tmp_9);
  kappa->nue[1] = NRPyLeakage_units_geom_to_cgs_L*(tmp_13*tmp_14*tmp_5 + tmp_14*tmp_16 + tmp_14*tmp_5*tmp_9);
  kappa->anue[0] = NRPyLeakage_units_geom_to_cgs_L*(tmp_16*tmp_20 + tmp_20*tmp_23*tmp_5 + tmp_20*tmp_5*tmp_9);
  kappa->anue[1] = NRPyLeakage_units_geom_to_cgs_L*(tmp_16*tmp_24 + tmp_23*tmp_24*tmp_5 + tmp_24*tmp_5*tmp_9);
  kappa->nux[0] = NRPyLeakage_units_geom_to_cgs_L*(tmp_16*tmp_26 + tmp_26*tmp_5*tmp_9);
  kappa->nux[1] = NRPyLeakage_units_geom_to_cgs_L*(tmp_16*tmp_28 + tmp_28*tmp_5*tmp_9);

  // Step 5: Make sure results are finite; if not reset to small value
  for(int i=0;i<2;i++) {
    if( !robust_isfinite(kappa->nue [i]) ) kappa->nue [i] = 1e-15;
    if( !robust_isfinite(kappa->anue[i]) ) kappa->anue[i] = 1e-15;
    if( !robust_isfinite(kappa->nux [i]) ) kappa->nux [i] = 1e-15;
  }
}
